# PART I -> HOW WEB API SECURITY WORKS
## 0 PREPARING FOR YOUR SECURITY TESTS
- API penetration testing requires a well-developed scope, or an account of the targets and features of what you are allowed to test, that ensures the client and tester have a mutual understanding of the work being done.
- Threat modeling is the process used to map out the threats to an API provider. If you model an API penetration test based on a relevant threat, you’ll be able to choose tools and techniques directed at that attack. The best test
### Threat Modeling an API Test
- A threat actor is the adversary or attacker of the API. The adversary can be anyone, from a member of the public who stumbles upon the API with little to no knowledge of the application to a customer using the application, a rogue business partner, or an insider who knows quite a bit about the application. To perform a test that provides the most value to the security of the API, it is ideal to map out the probable adversary as well as their hacking techniques
- A threat actor is the adversary or attacker of the API. The adversary can be anyone, from a member of the public who stumbles upon the API with little to no knowledge of the application to a customer using the application, a rogue business partner, or an insider who knows quite a bit about the application. To perform a test that provides the most value to the security of the API, it is ideal to map out the probable adversary as well as their hacking techniques.
- The most effective way to model a threat for a client is to conduct a survey with them. The survey will need to reveal the client’s scope of exposure to attacks, their economic significance, their political involvement, whether they are involved in any supply chains, whether they offer essential services, and whether there are other potential motives for a criminal to want to attack them. You can develop your own survey or put one together from existing professional resources like MITRE ATT&CK (https://attack.mitre.org) or OWASP (https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_ Sheet.html).
### Which API Features You Should Test
#### API Authenticated testing
- API Authenticated Testing Determine how the client wants to handle the testing of authenticated and unauthenticated users. The client may want to have you test different API users and roles to see if there are vulnerabilities present in any of the different privilege levels.
#### Mobile application testing
#### Rate Limit Testing 
## 1 HOW WEB APPLICATIONS WORK
- The term web application refers to software that is running on a web server, such as Wikipedia, LinkedIn, Twitter, Gmail, GitHub, and Reddit. In particular, web applications are designed for end-user interactivity. Whereas websites are typically read-only and provide one-way communication from the web server to the client, web applications allow communications to flow in both directions, from server to client and from client to server
- 
### THE URL, HTTP REQUESTS/RESPONSES, STATUS CODES , METHODS
- the URL P16
- HTTP requests P17
- HTTP responses P18
- HTTP status codes P19
- HTTP methods P20
- stateful and stateless HTTP 22

`Protocol://hostname[:port number]/[path]/[?query][parameters]`
## 2 THE ANATOMY OF WEB API's
- Resources are the data being requested. A singleton resource is a unique object, such as /api/user/{user_id}. A collection is a group of resources, such as /api/profiles/users. A subcollection refers to a collection within a particular resource. For example, /api/user/{user_id}/settings is the endpoint to access the settings subcollection of a specific (singleton) user. When a consumer requests a resource from a provider, the request passes through an API gateway, which is an API management component that acts as an entry point to a web application. For example, as shown in Figure 2-1, end users can access an application’s services using a plethora of devices, which are all filtered through an API gateway.
- The API gateway then distributes the requests to whichever microservice is needed to fulfill each request. The API gateway filters bad requests, monitors incoming traffic, and routes each request to the proper service or microservice. The API gateway can also handle security controls such as authentication, authorization, encryption in transit using SSL, rate limiting, and load balancing.
- A microservice is a modular piece of a web app that handles a specific function. Microservices use APIs to transfer data and trigger actions. For example, a web application with a payment gateway may have several different features on a single web page: a billing feature, a feature that logs customer account information, and one that emails receipts upon purchase. The application’s backend design could be monolithic, meaning all the services exist within a single application, or it could have a microservice architecture, where each service functions as its own standalone application.
- Tokens are what API providers use to identify and authorize requests to approved API consumers.
- By convention, curly brackets mean that a given variable is necessary within the path parameters. The {client_id} variable must be replaced with an actual client’s ID, and the {access_token} variable must be replaced with your own access token. Tokens are what API providers use to identify and authorize requests to approved API consumers. Other API documentation might use a colon or square brackets to signify a variable (for example, `/api/v2/:customers/ or /api/:collection/:client_id)`
### RESTful API
#RESTFUL-API 
- RESTful design depends on six constraints. These constraints are “shoulds” instead of “musts,” reflecting the fact that REST is essentially a set of guidelines for an HTTP resource-based architecture: 
	1. Uniform interface: REST APIs should have a uniform interface. In other words, the requesting client device should not matter; a mobile device, an IoT (internet of things) device, and a laptop must all be able to access a server in the same way. 
	2. Client/server: REST APIs should have a client/server architecture. Clients are the consumers requesting information, and servers are the providers of that information. 
	3. Stateless: REST APIs should not require stateful communications. REST APIs do not maintain state during communication; it is as though each request is the first one received by the server. The consumer will therefore need to supply everything the provider will need in order to act upon the request. This has the benefit of saving the provider from having to remember the consumer from one request to another. Consumers often provide tokens to create a state-like experience. 
	4. Cacheable: The response from the REST API provider should indicate whether the response is cacheable. Caching is a method of increasing request throughput by storing commonly requested data on the client side or in a server cache. When a request is made, the client will first check its local storage for the requested information. If it doesn’t find the information, it passes the request to the server, which checks its local storage for the requested information. If the data is not there either, the request could be passed to other servers, such as database servers, where the data can be retrieved.
	5. Layered system: The client should be able to request data from an endpoint without knowing about the underlying server architecture. 
	6. Code on demand (optional): Allows for code to be sent to the client for execution.
- REST is a style rather than a protocol, so each RESTful API may be different. It may have methods enabled beyond CRUD, its own sets of authentication requirements, subdomains instead of paths for endpoints, different rate-limit requirements, and so on. Furthermore, developers or an organization may call their API “RESTful” without adhering to the standard, which means you can’t expect every API you come across to meet all the REST constraints
#### Common REST API headers
#HTTP #RESTFUL-API 
- Authorization Authorization headers are used to pass a token or credentials to the API provider. The format of these headers is Authorization: . For example, take a look at the following authorization header: `Authorization: Bearer Ab4dtok3n` There are different authorization types. Basic uses base64-encoded credentials. Bearer uses an API token. Finally, AWS-HMAC-SHA256 is an AWS authorization type that uses an access key and a secret key.
- Content Type Content-Type headers are used to indicate the type of media being transferred. These headers differ from Accept headers, which state the media type you want to receive; Content-Type headers describe the media you’re sending. Here are some common Content-Type headers for REST APIs: 
	- application/json Used to specify JavaScript Object Notation (JSON) as a media type. JSON is the most common media type for REST APIs. 
	- application/xml Used to specify XML as a media type. 
	- application/x-www-form-urlencoded A format in which the values being sent are encoded and separated by an ampersand (&), and an equal sign (=) is used between key/value pairs.
	- Middleware (X) Headers X- headers are known as middleware headers and can serve all sorts of purposes. They are fairly common outside of API requests as well. 
		- X-Response-Time can be used as an API response to indicate how long a response took to process. 
		- X-API-Key can be used as an authorization header for API keys. 
		- X-Powered-By can be used to provide additional information about backend services. 
		- X-Rate-Limit can be used to tell the consumer how many requests they can make within a given time frame. 
		- X-RateLimitRemaining can tell a consumer how many requests remain before they violate rate-limit enforcement. (There are many more, but you get the idea.) 
		- X- middleware headers can provide a lot of useful information to API consumers and hackers alike...
### SOAP
#SOAP
- SOAP API messages are made up of four parts: the envelope 1 and header 2, which are necessary, and the body 3 and fault 4, which are optional. The envelope is an XML tag at the beginning of a message that signifies that the message is a SOAP message. The header can be used to process a message; in this example, the Content-Type request header lets the SOAP provider know the type of content being sent in the POST request (application/ soap+xml). Since APIs facilitate machine-to-machine communication, headers essentially form an agreement between the consumer and the provider concerning the expectations within the request. Headers are a way to ensure that the consumer and provider understand one another and are speaking the same language. The body is the primary payload of the XML message, meaning it contains the data sent to the application. The fault is an optional part of a SOAP response that can be used to provide error messaging.
### JSON TYPES 
#JSON 
- P68/363
### XML
#XML
- The Extensible Markup Language (XML) format has been around for a while, and you’ll probably recognize it. XML is characterized by the descriptive tags it uses to wrap data. Although REST APIs can use XML, it is most commonly associated with SOAP APIs. SOAP APIs can only use XML as the data interchange
- XML always begins with a prolog, which contains information about the XML version and encoding used 1. Next, elements are the most basic parts of XML. An element is any XML tag or information surrounded by tags. XML must have a root element and can contain child elements. In the example, the root element is 2. The child elements are XML attributes.
- 
### YAML
#YAML
- Another lightweight form of data exchange used in APIs, YAML is a recursive acronym that stands for YAML Ain’t Markup Language. It was created as a more human- and computer-readable format for data exchange. Like JSON, YAML documents contain key/value pairs. The value may be any of the YAML data types, which include numbers, strings, Booleans, null values, and sequences.
- You’ll notice that YAML is much more readable than JSON. YAML documents begin with `---` end with `...` , instead of with curly brackets. Also, quotes around strings are optional. Additionally, URLs don’t need to be encoded with backslashes. Finally, YAML uses indentation instead of curly brackets to represent nesting and allows for comments beginning with #. API specifications will often be formatted as JSON or YAML, because these formats are easy for humans to digest.
### API auth-n
- REST and GraphQL APIs are stateless, so when a consumer authenticates to these APIs, no session is created between the client and server. Instead, the API consumer must prove their identity within every request sent to the API provider’s web server.
#### Basic auth-n
- The simplest form of API authentication is HTTP basic authentication, in which the consumer includes their username and password in a header or the body of a request. The API could either pass the username and password to the provider in plaintext, like username:password, or it could encode the credentials using something like base64 to save space.
- basic authentication has no inherent security and completely depends on other security controls. An attacker can compromise basic authentication by capturing HTTP traffic, performing a man-in-the middle attack, tricking the user into providing their credentials through social engineering tactics, or performing a brute-force attack in which they attempt various usernames and passwords until they find some that work. Since APIs are often stateless, those using only basic authentication require the consumer to provide credentials in every request. It is common for an API provider to instead use basic authentication once, for the first request, and then issue an API key or some other token for all other requests
#### API keys
- API keys are unique strings that API providers generate and grant to authorize access for approved consumers. Once an API consumer has a key, they can include it in requests whenever specified by the provider. The provider will typically require that the consumer pass the key in query string parameters, request headers, body data, or as a cookie when they make a request.
	- API key included in query string `/api/v1/users?apikey=ju574n3x4mpl34p1k3y`
	- API key included as a header `"API-Secret": "17813fg8-46a7-5006-e235-45be7e9f2345"`
	- API key passed in as a cookie `Cookie: API-Key= 4n07h3r4p1k3y`
- The process of acquiring an API key depends on the provider
- API keys can be more secure than basic authentication for several reasons. When keys are sufficiently long, complex, and randomly generated, they can be exceedingly difficult for an attacker to guess or brute-force. Additionally, providers can set expiration dates to limit the length of time for which the keys are valid. However, API keys have several associated risks that we will take advantage of later in this book. Since each API provider may have their own system for generating API keys, you’ll find instances in which the API key is generated based on user data. In these cases, API hackers may guess or forge API keys by learning about the API consumers. API keys may also be exposed to the internet in online repositories, left in code comments, intercepted when transferred over unencrypted connections, or stolen through phishing.
#### JSON WEB TOKENS (JWT)
#JWT
- A JSON Web Token (JWT) is a type of token commonly used in API token-based authentication. It’s used like this: The API consumer authenticates to the API provider with a username and password. The provider generates a JWT and sends it back to the consumer. The consumer adds the provided JWT to the Authorization header in all API requests. 
- JWTs consist of three parts, all of which are base64-encoded and separated by periods: the header, the payload, and the signature. The header includes information about the algorithm used to sign the payload. The payload is the data included within the token, such as a username, timestamp, and issuer. The signature is the encoded and encrypted message used to validate the token.
- JWTs are generally secure but can be implemented in ways that will compromise that security. API providers can implement JWTs that do not use encryption, which means you would be one base64 decode away from being able to see what is inside the token. An API hacker could decode such a token, tamper with the contents, and send it back to the provider to gain access.
- The JWT secret key may also be stolen or guessed by brute force.
#### HMAC (hash-based message auth-n code)
#HMAC
- A hash-based message authentication code (HMAC) is the primary API authentication method used by Amazon Web Services (AWS). When using HMAC, the provider creates a secret key and shares it with consumer. When a consumer interacts with the API, an HMAC hash function is applied to the consumer’s API request data and secret key. The resulting hash (also called a message digest) is added to the request and sent to the provider. The provider calculates the HMAC, just as the consumer did, by running the message and key through the hash function, and then compares the output hash value to the value provided by the client. If the provider’s hash value matches the consumer’s hash value, the consumer is authorized to make the request. If the values do not match, either the client’s secret key is incorrect or the message has been tampered with.
	- HMAC algorithms include HMAC-MD5, HMAC-SHA1, HMAC-SHA256, HMAC-SHA512
- You may have some red flags regarding the use of SHA1 or MD5. As of the writing of this book, there are currently no known vulnerabilities affecting HMAC-SHA1 and HMAC-MD5, but these functions are cryptographically weaker than SHA-256 and SHA-512. However, the more secure functions are also slower. The choice of which hash function to use comes down to prioritizing either performance or security.
- As with the previous authentication methods covered, the security of HMAC depends on the consumer and provider keeping the secret key private. If a secret key is compromised, an attacker could impersonate the victim and gain unauthorized access to the API.
#### OAuth
#OAuth
- OAuth 2.0, or just OAuth, is an authorization standard that allows different services to access each other’s data, often using APIs to facilitate the service-to-service communications. Let’s say you want to automatically share your Twitter tweets on LinkedIn. In OAuth’s model, we would consider Twitter to be the service provider and LinkedIn to be the application or client. In order to post your tweets, LinkedIn will need authorization to access your Twitter information. Since both Twitter and LinkedIn have implemented OAuth, instead of providing your credentials to the service provider and consumer every time you want to share this information across platforms, you can simply go into your LinkedIn settings and authorize Twitter.
- OAuth is one of the most trusted forms of API authorization. However, while it adds security to the authorization process, it also expands the potential attack surface—although flaws often have more to do with how the API provider implements OAuth than with OAuth itself. API providers that poorly implement OAuth can expose themselves to a variety of attacks such as token injection, authorization code reuse, cross-site request forgery, invalid redirection, and phishing.
#### No Authentication
- As in web applications generally, there are plenty of instances where it is valid for an API to have no authentication at all. If an API does not handle sensitive data and only provides public information, the provider could make the case that no authentication is necessary
## 3 COMMON API VULNERABILITIES
### Information disclosure
- When an API and its supporting software share sensitive information with unprivileged users, the API has an information disclosure vulnerability. Information may be disclosed in API responses or public sources such as code repositories, search results, news, social media, the target’s website, and public API directories. Sensitive data can include any information that attackers can leverage to their advantage.
- Another common information disclosure issue involves verbose messaging. Error messaging helps API consumers troubleshoot their interactions with an API and allows API providers to understand issues with their application. However, it can also reveal sensitive information about resources, users, and the API’s underlying architecture (such as the version of the web server or database).
- Finding user information is a great way to start gaining access to an API. The following information can also be leveraged in an attack: software packages, operating system information, system logs, and software bugs. 
- Generally, any information that can help us find more severe vulnerabilities or assist in exploitation can be considered an information disclosure vulnerability. Often, you can gather the most information by interacting with an API endpoint and analyzing the response. API responses can reveal information within headers, parameters, and verbose errors. Other good sources of information are API documentation and resources gathered during reconnaissance.
### Broken object level authorization (BOLA)
- One of the most prevalent vulnerabilities in APIs is broken object level authorization (BOLA). BOLA vulnerabilities occur when an API provider allows an API consumer access to resources they are not authorized to access. If an API endpoint does not have object-level access controls, it won’t perform checks to make sure users can only access their own resources. When these controls are missing, User A will be able to successfully request User B’s resources. APIs use some sort of value, such as names or numbers, to identify various objects. When we discover these object IDs, we should test to see if we can interact with the resources of other users when unauthenticated or authenticated as a different user.
- If you can successfully access information you shouldn’t be authorized to access, you have discovered a BOLA vulnerability.
- BOLA can be a low-hanging API vulnerability that you can easily discover using pattern recognition and then prodding it with a few requests. Other times, it can be quite complicated to discover due to the complexities of object IDs and the requests used to obtain another user’s resources.
### BROKEN USER AUTH-N
- Broken user authentication refers to any weakness within the API authentication process. These vulnerabilities typically occur when an API provider either doesn’t implement an authentication protection mechanism or implements a mechanism incorrectly.
- API authentication can be a complex system that includes several processes with a lot of room for failure. A couple decades ago, security expert Bruce Schneier said, “The future of digital systems is complexity, and complexity is the worst enemy of security.” As we know from the six constraints of REST APIs discussed in Chapter 2, RESTful APIs are supposed to be stateless. In order to be stateless, the provider shouldn’t need to remember the consumer from one request to another. For this constraint to work, APIs often require users to undergo a registration process in order to obtain a unique token. 
	- Users can then include the token within requests to demonstrate that they’re authorized to make such requests. As a consequence, the registration process used to obtain an API token, the token handling, and the system that generates the token could all have their own sets of weaknesses. To determine if the token generation process is weak, for example, we could collect a sampling of tokens and analyze them for similarities. If the token generation process doesn’t rely on a high level of randomness, or entropy, there is a chance we’ll be able to create our own token or hijack someone else’s. 
	- **Token handling** could be the storage of tokens, the method of transmitting tokens across a network, the presence of hardcoded tokens, and so on. We might be able to detect hardcoded tokens in JavaScript source files or capture them as we analyze a web application. Once we’ve captured a token, we can use it to gain access to previously hidden endpoints or to bypass detection. If an API provider attributes an identity to a token, we would then take on the identity by hijacking the stolen token.
### Excessive Data Exposure
- Excessive data exposure is when an API endpoint responds with more information than is needed to fulfill a request. This often occurs when the provider expects the API consumer to filter results; in other words, when a consumer requests specific information, the provider might respond with all sorts of information, assuming the consumer will then remove any data they don’t need from the response.
- All you need to do to detect excessive data exposure is test your target API endpoints and review the information sent in response.
### Lack of Resources and Rate Limiting
- One of the more important vulnerabilities to test for is lack of resources and rate limiting. Rate limiting plays an important role in the monetization and availability of APIs. Without limiting the number of requests consumers can make, an API provider’s infrastructure could be overwhelmed by the requests. Too many requests without enough resources will lead to the provider’s systems crashing and becoming unavailable—a denial of service (DoS) state.
### Broken function level Auth-z (BFLA)
- Broken function level authorization (BFLA) is a vulnerability where a user of one role or group is able to access the API functionality of another role or group. API providers will often have different roles for different types of accounts, such as public users, merchants, partners, administrators, and so on. A BFLA is present if you are able to use the functionality of another privilege level or group. In other words, BFLA can be a lateral move, where you use the functions of a similarly privileged group, or it could be a privilege escalation, where you are able to use the functions of a more privileged group. Particularly interesting API functions to access include those that deal with sensitive information, resources that belong to another group, and administrative functionality such as user account management. 
- BFLA is similar to BOLA, except instead of an authorization problem involving accessing resources, it is an authorization problem for performing actions. For example, consider a vulnerable banking API. When a BOLA vulnerability is present in the API, you might be able to access the information of other accounts, such as payment histories, usernames, email addresses, and account numbers. If a BFLA vulnerability is present, you might be able to transfer money and actually update the account information. BOLA is about unauthorized access, whereas BFLA is about unauthorized actions.
- When hunting for BFLA, look for any functionality you could use to your advantage, including altering user accounts, accessing user resources, and gaining access to restricted endpoints. 
	- For example, if an API gives partners the ability to add new users to the partner group but does not restrict this functionality to the specific group, any user could add themselves to any group. Moreover, if we’re able to add ourselves to a group, there is a good chance we’ll be able to access that group’s resources. The easiest way to discover BFLA is to find administrative API documentation and send requests as an unprivileged user that test admin functions and capabilities
### Mass assignment
- Mass assignment occurs when an API consumer includes more parameters in their requests than the application intended and the application adds these parameters to code variables or internal objects. In this situation, a consumer may be able to edit object properties or escalate privileges.
- You can discover mass assignment vulnerabilities by finding interesting parameters in API documentation and then adding those parameters to a request. Look for parameters involved in user account properties, critical functions, and administrative actions. Intercepting API requests and responses could also reveal parameters worthy of testing
### Security Misconfigurations
- Security misconfigurations include all the mistakes developers could make within the supporting security configurations of an API. If a security misconfiguration is severe enough, it can lead to sensitive information exposure or a complete system takeover.
- Security misconfigurations are really a set of weaknesses that includes misconfigured headers, misconfigured transit encryption, the use of default accounts, the acceptance of unnecessary HTTP methods, a lack of input sanitization, and verbose error messaging.
- A lack of input sanitization can allow attackers to upload malicious payloads to the server. APIs often play a key role in automating processes, so imagine being able to upload payloads that the server automatically processes into a format that could be remotely executed or executed by an unsuspecting end user.
	- Additionally, lack of input sanitization can lead to unexpected behavior on the part of the application.
- API providers use headers to provide the consumer with instructions for handling the response and security requirements. Misconfigured headers can result in sensitive information disclosure, downgrade attacks, and cross-site scripting attacks.
	- The X-Powered-By header reveals backend technology. Headers like this one will often advertise the exact supporting service and its version. You could use information like this to search for exploits published for that version of software. 
	- X-XSS-Protection is exactly what it looks like: a header meant to prevent cross-site scripting (XSS) attacks. XSS is a common type of injection vulnerability where an attacker can insert scripts into a web page and trick end users into clicking malicious links. We will cover XSS and cross-API scripting (XAS) in Chapter 12. An X-XSS-Protection value of 0 indicates no protections are in place, and a value of 1 indicates that protection is turned on. This header, and others like it, clearly reveals whether a security control is in place.
	- The X-Response-Time header is middleware that provides usage metrics. In the previous example, its value represents 566.43 milliseconds. However, if the API isn’t configured properly, this header can function as a side channel used to reveal existing resources. If the X-Response-Time header has a consistent response time for nonexistent records, for example, but increases its response time for certain other records, this could be an indication that those records exist.
- Any API providing sensitive information to consumers should use Transport Layer Security (TLS) to encrypt the data. Even if the API is only provided internally, privately, or at a partner level, using TLS, the protocol that encrypts HTTPS traffic, is one of the most basic ways to ensure that API requests and responses are protected when being passed across a network.
- When a service uses a default account and credentials and the defaults are known, an attacker can use those credentials to assume the role of that account. This could allow them to gain access to sensitive information or administrative functionality, potentially leading to a compromise of the supporting systems. 
- Lastly, if an API provider allows unnecessary HTTP methods, there is an increased risk that the application won’t handle these methods properly or will result in sensitive information disclosure. 
- You can detect several of these security misconfigurations with web application vulnerability scanners such as Nessus, Qualys, OWASP ZAP, and Nikto. These scanners will automatically check the web server version information, headers, cookies, transit encryption configuration, and parameters to see if expected security measures are missing. You can also check for these security misconfigurations manually, if you know what you are looking for, by inspecting the headers, SSL certificate, cookies, and parameters.
### Injection
- Injection flaws exist when a request is passed to the API’s supporting infrastructure and the API provider doesn’t filter the input to remove unwanted characters (a process known as input sanitization). As a result, the infrastructure might treat data from the request as code and run it. When this sort of flaw is present, you’ll be able to conduct injection attacks such as SQL injection, NoSQL injection, and system command injection. 
- In each of these injection attacks, the API delivers your un-sanitized payload directly to the operating system running the application or its database. As a result, if you send a payload containing SQL commands to a vulnerable API that uses a SQL database, the API will pass the commands to the database, which will process and perform the commands. The same will happen with vulnerable NoSQL databases and affected systems.
- Finding injection flaws requires diligently testing API endpoints, paying attention to how the API responds, and then crafting requests that attempt to manipulate the backend systems. Like directory traversal attacks, injection attacks have been around for decades, so there are many standard security controls to protect API providers from them.
### Improper Assets Management
- Improper assets management takes place when an organization exposes APIs that are either retired or still in development. As with any software, old API versions are more likely to contain vulnerabilities because they are no longer being patched and upgraded. Likewise, APIs that are still being developed are typically not as secure as their production API counterparts. Improper assets management can lead to other vulnerabilities, such as excessive data exposure, information disclosure, mass assignment, improper rate limiting, and API injection.
- For attackers, discovering an improper assets management vulnerability is only the first step toward further exploitation of an API. 
- You can discover improper assets management by paying close attention to outdated API documentation, changelogs, and version history on repositories.
- Organizations often include versioning information in their endpoint names to distinguish between older and newer versions, such as ***/v1/, /v2/, /v3/,*** and so on. 
	- APIs still in development often use paths such as ***/alpha/, /beta/, /test/, /uat/, and /demo/***. If you know that an API is now using `apiv3.org/admin` but part of the API documentation refers to `apiv1.org/admin`, you could try testing different endpoints to see if apiv1 or apiv2 is still active. Additionally, the organization’s changelog may disclose the reasons why v1 was updated or retired. If you have access to v1, you can test for those weaknesses. Outside of using documentation, you can discover improper assets management vulnerabilities through the use of guessing, fuzzing, or brute-force requests. Watch for patterns in the API documentation or path-naming scheme, and then make requests based on your assumptions.
### Basic Logic Vulnerabilities
- Business logic vulnerabilities (also known as business logic flaws, or BLFs) are intended features of an application that attackers can use maliciously. For example, if an API has an upload feature that doesn’t validate encoded payloads, a user could upload any file as long as it was encoded. This would allow end users to upload and execute arbitrary code, including malicious payloads. 
- Vulnerabilities of this sort normally come about from an assumption that API consumers will follow directions, be trustworthy, or only use the API in a certain way. In those cases, the organization essentially depends on trust as a security control by expecting the consumer to act benevolently. Unfortunately, even good-natured API consumers make mistakes that could lead to a compromise of the application.
- Another problem with trust is that credentials, such as API keys, tokens, and passwords, are constantly being stolen and leaked.
- You can search API documentation for telltale signs of business logic vulnerabilities. Statements like the following should illuminate the lightbulb above your head: 
```
“Only use feature X to perform function Y.” 
“Do not do X with endpoint Y.” 
“Only admins should perform request X.”
```
- These statements may indicate that the API provider is trusting that you won’t do any of the discouraged actions, as instructed. When you attack their API, make sure to disobey such requests to test for the presence of security controls. Another business logic vulnerability comes about when developers assume that consumers will exclusively use a browser to interact with the web application and won’t capture API requests that take place behind the scenes. All it takes to exploit this sort of weakness is to intercept requests with a tool like Burp Suite Proxy or Postman and then alter the API request before it is sent to the provider.
- Testing for business logic flaws can be challenging because each business is unique. Automated scanners will have a difficult time detecting these issues, as the flaws are part of the API’s intended use. You must understand how the business and API operate and then consider how you could use these features to your advantage. Study the application’s business logic with an adversarial mindset, and try breaking any assumptions that have been made.
# PART II -> BUILDING AN API TESTING LAB
## 4 YOUR API HACKING SYSTEM
### Analyzing Web Apps with DevTools
- For more information about DevTools, check out the Google Developers documentation at https://developers.google.com/web/tools/chrome-devtools.
- Elements Allows you to view the current page’s CSS and Document Object Model (DOM), which enables you to inspect the HTML that constructs the web page. 
- Console Provides you with alerts and lets you interact with the JavaScript debugger to alter the current web page. 
- Sources Contains the directories that make up the web application and the content of the source files. 
- Network Lists all the source file requests that make up the client’s perspective of the web application. 
- Performance Provides a way to record and analyze all the events that take place when loading a web page. 
- Memory Lets you record and analyze how the browser is interacting with your system’s memory. 
- Application Provides you with the application manifest, storage items (like cookies and session information), cache, and background services. 
- Security Provides insight regarding the transit encryption, source content origins, and certificate details.
### Altering requests with intruder
- Sniper is the simplest attack type; it replaces the added attack position with a string provided from a single set of payloads. A sniper attack is limited to using a single payload, but it can have several attack positions. A sniper attack will replace one attack position per request, cycling through the different attack positions in each request.
- Battering ram is like the sniper attack in that it also uses one payload, but it will use that payload across all attack positions in a request. If you were testing for SQL injection across several input positions within a request, you could fuzz them all simultaneously with battering ram.
- Pitchfork is used for testing multiple payload combinations at the same time. For example, if you have a list of leaked usernames and password combinations, you could use two payloads together to test whether any of the credentials were used with the application being tested. However, this attack doesn’t try out different combinations of payloads; it will only cycle through the payload sets like this: user1:pass1, user2:pass2, user3:pass3.
- Cluster bomb will cycle through all possible combinations of the payloads provided. If you provide two usernames and three passwords, the payloads would be used in the following pairs
- Intruder should help you find API vulnerabilities such as broken object level authorization, excessive data exposure, broken authentication, broken function level authorization, mass assignment, injection, and improper assets management. Intruder is essentially a smart fuzzing tool that provides a list of results containing the individual requests and responses. You can interact with the request you’d like to fuzz and replace the attack position with the input of your choice. These API vulnerabilities are typically discovered by sending the right payload to the right location
### extending the power of burp suite
- autorize
- inql scanner
- JSON web tokens
- ip rotate
- bypass WAF
### crafting API requests in postman, an API browser
#postman
#### the request builder
- this is the place that lets us craft each request by adding parameters, authorization headers and so on
- it has several tabs useful for precisely constructing the parameters, headers and body of a request.
	- params tab: is where we can add query and path parameters to a request. allows enter various key/value pairs along with a description of those parameters
	- authorization tab: includes many standard forms of authorization headers for you to include in your request.
	- headers tab: includes the key and value pairs required for certain HTTP requests.
- the request builder can also run pre-request scripts, which can chain together different requests that depend on each other. For example, if request 1 issues a resource value that is needed for the following request, you can script that resource value to automatically be added to request 2.
- P116/363 request builder panels 
	- An environment provides a way to store and use the same variables across APIs. An environmental variable is a value that will replace a variable across an environment.
	- Collections are groups of API requests that can be imported into Postman. If an API provider offers a collection, you won’t have to physically type in every single request. Instead, you can just import its collection
	- The Collection Runner The Collection Runner allows you to run all the saved requests in a collection
	- In addition to the panels, you should also be aware of the code snippets feature. At the top-right of the request pane, you’ll see a Code button. This button can be used to translate the built request into many different formats, including cURL, Go, HTTP, JavaScript, NodeJS, PHP, and Python.
	- The Tests panel allows you to create scripts that will be run against responses to your requests. If you are not a programmer, you will appreciate that Postman has made prebuilt code snippets available on the right side of the Tests panel
		- I suggest checking out the following snippets: 
		-  Status code: Code is 200 
		- Response time is less than 200ms 
		- Response body: contains string
### supplemental tools
P124/363
- OWASP ZAP 
- NIKTO
- Wfuzz
- Arjun
# PART III: ATTACKING APIs
## 6 DISCOVERY
- Before you can attack a target’s APIs, you must locate those APIs and validate whether they are operational. In the process, you’ll also want to find credential information (such as keys, secrets, usernames, and passwords), version information, API documentation, and information about the API’s business purpose. The more information you gather about a target, the better your odds of discovering and exploiting API-related vulnerabilities. This chapter describes passive and active reconnaissance processes and the tools to get the job done.
### PASSIVE RECON
- Passive reconnaissance is the act of obtaining information about a target without directly interacting with the target’s devices.
- Any discovered API endpoints will become your targets later, during active reconnaissance. Credential-related information will help you test as an authenticated user or, better, as an administrator. Version information will help inform you about potential improper assets and other past vulnerabilities. API documentation will tell you exactly how to test the target API. Finally, discovering the API’s business.
- As you are collecting OSINT, it is entirely possible you will stumble upon a critical data exposure, such as API keys, credentials, JSON Web Tokens (JWT), and other secrets that would lead to an instant win. Other high-risk findings would include leaked PII or sensitive user data such as Social Security numbers, full names, email addresses, and credit card information. These sorts of findings should be documented and reported immediately because they present a valid critical weakness.
#### The Passive Recon Process
- **Phase One: Cast a Wide Net** 
- Search the internet for very general terms to learn some fundamental information about your target. 
	- Search engines such as Google, Shodan, and ProgrammableWeb can help you find general information about the API, such as its usage, design and architecture, documentation, and business purpose, as well as industry-related information and many other potentially significant items. Additionally, you need to investigate your target’s attack surface. This can be done with tools such as DNS Dumpster and OWASP Amass. DNS Dumpster performs DNS mapping by showing all the hosts related to the target’s domain name and how they connect to each other.
- **Phase Two: Adapt and Focus Next,**
	- take your findings from phase one and adapt your OSINT efforts to the information gathered. This might mean increasing the specificity of your search queries or combining the information gathered from separate tools to gain new insights. In addition to using search engines, you might search GitHub for repositories related to your target and use a tool such as Pastehunter to find exposed sensitive information.
- Phase Three: Document the Attack Surface
	- Taking notes is crucial to performing an effective attack. Document and take screen captures of all interesting findings. Create a task list of the passive reconnaissance findings that could prove useful throughout the rest of the attack.
	- **GOOGLE HACKING** (P153/363)
	- **ProgrammableWeb** (P155/363)
	- **SHODAN** (P157/363)
	- **OWASP AMASS** (P159/363)
### ACTIVE RECON
- One shortcoming of performing passive reconnaissance is that you’re collecting information from secondhand sources. As an API hacker, the best way to validate this information is to obtain information directly from a target by port or vulnerability scanning, pinging, sending HTTP requests, making API calls, and other forms of interaction with a target’s environment. 
- This section will focus on discovering an organization’s APIs using detection scanning, hands-on analysis, and targeted scanning. The lab at the end of the chapter will show these techniques in action.
#### The Active Recon Process
- This process is time-efficient because it keeps you engaging with the target while automated scans are running in the background. 
	- Whenever you’ve hit a dead end in your analysis, return to your automated scans to check for new findings.
- The process is not linear: after each phase of increasingly targeted scanning, you’ll analyze the results and then use your findings for further scanning. At any point, you might find a vulnerability and attempt to exploit it. If you successfully exploit the vulnerability, you can move on to post-exploitation. If you don’t, you return to your scans and analysis. 
##### Phase Zero: Opportunistic Exploitation
- If you discover a vulnerability at any point in the active recon process, you should take the opportunity to attempt exploitation. You might discover the vulnerability in the first few seconds of scanning, after stumbling upon a comment left in a partially developed web page, or after months of research. As soon as you do, dive into exploitation and then return to the Discovery phased process as needed. With experience, you’ll learn when to avoid getting lost in a potential rabbit hole and when to go all in on an exploit.
##### Phase One: Detection Scanning
- The goal of detection scanning is to reveal potential starting points for your investigation. Begin with general scans meant to detect hosts, open ports, services running, and operating systems currently in use, as described in the “Baseline Scanning with Nmap” section of this chapter. APIs use HTTP or HTTPS, so as soon as your scan detects these services, let the scan continue to run and move into phase two.
##### Phase Two: Hands-on Analysis
- Hands-on analysis is the act of exploring the web application using a browser and API client. Aim to learn about all the potential levers you can interact with and test them out. Practically speaking, you’ll examine the web page, intercept requests, look for API links and documentation, and develop an understanding of the business logic involved.
- You should usually consider the application from three perspectives: guests, authenticated users, and site administrators.
	- ***Guest*** How would a new user use this site? Can new users interact with the API? Is API documentation public? What actions can this group perform? 
	- ***Authenticated User*** What can you do when authenticated that you couldn’t do as a guest? Can you upload files? Can you explore new sections of the web application? Can you use the API? How does the web application recognize that a user is authenticated? 
	- ***Administrator*** Where would site administrators log in to manage the web app? What is in the page source? What comments have been left around various pages? What programming languages are in use? What sections of the website are under development or experimental?
- Next, it’s time to analyze the app as a hacker by intercepting the HTTP traffic with Burp Suite. When you use the web app’s search bar or attempt to authenticate, the app might be using API requests to perform the requested action, and you’ll see those requests in Burp Suite.
- When you run into roadblocks, it’s time to review new results from the phase one scans running in the background and kick off phase three: targeted scans.
##### Phase Three: Targeted Scanning
- In the targeted scanning phase, refine your scans and use tools that are specific to your target. Whereas detection scanning casts a wide net, targeted scanning should focus on the specific type of API, its version, the web application type, any service versions discovered, whether the app is on HTTP or HTTPS, any active TCP ports, and other information gleaned from understanding the business logic.
- ***Baseline Scanning with Nmap***
	- The Nmap general detection scan uses default scripts and service enumeration against a target and then saves the output in three formats for later review (-oX for XML, -oN for Nmap, -oG for greppable, or -oA for all three formats):
	- `$ nmap -sC -sV -oA nameofoutput`
	- The Nmap all-port scan will quickly check all 65,535 TCP ports for running services, application versions, and host operating system in use:
		- `$ nmap -p- -oA allportscan`
- ***Finding Hidden Paths in Robots.txt***
	- Robots.txt is a common text file that tells web crawlers to omit results from the search engine findings. Ironically, it also serves to tell us which paths the target wants to keep secret. You can find the robots.txt file by navigating to the target’s /robots.txt directory (for example, https://www.twitter.com/robots.txt).
- ***Finding Sensitive Information with Chrome DevTools***
	- Begin by opening your target page and then open Chrome DevTools with F12 or CTRL-SHIFT-I. Adjust the Chrome DevTools window until you have enough space to work with. Select the Network tab and then refresh the page. Now look for interesting files (you may even find one titled “API”). Right-click any JavaScript files that interest you and click Open in Sources Panel (see Figure 6-12) to view their source code. Alternatively, click XHR to find see the Ajax requests being made.
	- Search for potentially interesting lines of JavaScript. Some key terms to search for include “API,” “APIkey,” “secret,” and “password.”
	- You can also make use of the ***DevTools Memory tab***, which allows you to take a snapshot of the memory heap distribution. Sometimes the static JavaScript files include all sorts of information and thousands of lines of code. In other words, it may not be entirely clear exactly how the web app leverages an API. Instead, you could use the Memory panel to record how the web application is using resources to interact with an API.
		- With DevTools open, click the Memory tab. Under Select Profiling Type, choose Heap Snapshot. Then, under Select JavaScript VM Instance, choose the target to review. Next, click the Take Snapshot button (see Figure 6-14).
		- Once the file has been compiled under the Heap Snapshots section on the left, select the new snapshot and use CTRL-F to search for potential API paths. Try searching for terms using the common API path terms, like “api,” “v1,” “v2,” “swagger,” “rest,” and “dev.” If you need additional inspiration, check out the Assetnote API wordlists (http://wordlists.assetnote.io). If you’ve built your attack machine according to Chapter 4, these wordlists should be available to you under /api/wordlists
- ***Crawling URIs wisth OWASP ZAP***
	- One of the objectives of active reconnaissance is to discover all of a web page’s directories and files, also known as URIs, or uniform resource identifiers. There are two approaches to discovering a site’s URIs: crawling and brute force. OWASP ZAP crawls web pages to discover content by scanning each page for references and links to other web pages.
	- After the automated scan commences, you can watch the live results using the Spider or Sites tab. You may discover API endpoints in these tabs. If you do not find any obvious APIs, use the Search tab, shown in Figure 6-19, and look for terms like “API,” “GraphQL,” “JSON,” “RPC,” and “XML” to find potential API endpoints.
	- Once you’ve found a section of the site you want to investigate more thoroughly, begin manual exploration using the ZAP HUD to interact with the web application’s buttons and user input fields. While you do this, ZAP will perform additional scans for vulnerabilities. Navigate to the Quick Start tab and select Manual Explore (you may need to click the back arrow to exit the automated scan). On the Manual Explore screen, shown in Figure 6-20, select your desired browser and then click Launch Browser.
	- The ZAP HUD should now be enabled. Click Continue to Your Target in the ZAP HUD welcome screen (see Figure 6-21). Now you can manually explore the target web application, and ZAP will work in the background to automatically scan for vulnerabilities. In addition, ZAP will continue to search for additional paths while you navigate around the site
- ***Brute-Forcing URIs with Gobuster***
	- Gobuster can be used to brute-force URIs and DNS subdomains from the command line. (If you prefer a graphical user interface, check out OWASP’s Dirbuster.) In Gobuster, you can use wordlists for common directories and subdomains to automatically request every item in the wordlist, send the items to a web server, and filter the interesting server responses. The results generated from Gobuster will provide you with the URL path and the HTTP status response codes
- ***Discovering API Content with Kiterunner***
	- While Gobuster works well for a quick scan of a web application to discover URL paths, it typically relies on standard HTTP GET requests. Kiterunner will not only use all HTTP request methods common with APIs (GET, POST, PUT, and DELETE) but also mimic common API path structures. In other words, instead of requesting GET /api/v1/user/create,Kiterunner will try POST POST /api/v1/user/create, mimicking a more realistic request
## 7 ENDPOINT ANALYSIS
- 
# P125/363 setting up Amass up with API keys from various keys